import { ConstructReductionConfig } from "@constructs/ast/_abstract/_types";
import { InteractionContext } from "@constructs/ast/_abstract/_types/interaction/context/interactionContext";
import { ReductionLifecycleController } from "@constructs/ast/_abstract/_util/reduce/_util/lifecycle/types";
import getValueGeneratorAsync from "@constructs/ast/_abstract/_util/reduce/async/_util/getValueGeneratorAsync";
import { runEvaluationLifecycleAsync } from "@constructs/ast/_abstract/_util/reduce/async/_util/lifecycle/eval";
import { ComponentValueGenerationProcessorAsync } from "@constructs/ast/_abstract/_util/reduce/async/_util/types/componentProcessor";

/**
 * Returns a function that iterates over the values generated by a construct component.
 *
 * @param reductionConfig
 * @param lifecycle
 */
export function getValueGenerationProcessorAsync<Context extends InteractionContext, Intermediate = any>(
    reductionConfig: ConstructReductionConfig<Context>,
    lifecycle: ReductionLifecycleController
): ComponentValueGenerationProcessorAsync<Context, Intermediate> {
    return async ({ component, context, subject }): Promise<[Promise<Intermediate>[], Context]> => {
        // A mutable data structure useful throughout processing this component
        type Mut = {
            values: Promise<Intermediate>[];
            context: Context;
        };
        const mut = { values: [], context: context } as Mut;

        /**
         * For each location generated by the component,
         *  derive a subject and run the evaluation lifecycle method on it
         * @param subjectStep
         */
        async function processSubjectStep(subjectStep: [any, Context]) {
            if (!Array.isArray(subjectStep)) {
                mut.context = subjectStep;
                return false;
            }
            const subject   = subjectStep[0];
            const context   = subjectStep[1];
            const _step     = [subject, context] as [any, Context];
            const value     = await reductionConfig.deriveSubjectValue(_step, component.name, true);
            const evaluated = await runEvaluationLifecycleAsync(lifecycle, [value, context]);

            mut.context = evaluated.context;
            mut.values.push(...(evaluated.values as Promise<Intermediate>[]));
            return true;
        }


        // loop over each generated value
        {
            let promise;
            const componentValueGenerator = getValueGeneratorAsync(component, subject, context);
            while ((promise = componentValueGenerator.next())) {
                const { done, value: subjectStep } = await promise;
                if (done) {
                    mut.context = subjectStep;
                    break;
                }
                const okay = await processSubjectStep(subjectStep);
                if (okay) break;
            }
        }

        // next step
        return [mut.values, mut.context ?? context];
    };
}
